# https://wiki.seeedstudio.com/xiao_7_5_inch_epaper_panel_main_page/

logger:

api:
  encryption:
    key: !secret api_key

# Note: This device does deep sleep so it can't update OTA
ota:
  - platform: esphome
    password: !secret ota_password

json:

esphome:
  name: eink-panel

esp32:
  board: seeed_xiao_esp32c3
  variant: esp32c3
  framework:
    type: esp-idf

# Bus required for the display
spi:
  clk_pin: GPIO8
  mosi_pin: GPIO10

http_request:
  verify_ssl: false
  timeout: 10s
  watchdog_timeout: 15s


globals:
  # Variable turned on/off when Wi-Fi is connected and track refresh interval
  # until data has been loaded. The wifi status is also displayed on the screen.
  - id: wifi_status
    type: int
    restore_value: no
    initial_value: "0"
  - id: update_done
    type: bool
    restore_value: no 
    initial_value: "false"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  domain: !secret domain
  on_connect:
    then:
      - lambda: |-
          id(wifi_status) = 1;
  on_disconnect:
    then:
      - lambda: |-
          id(wifi_status) = 0;

deep_sleep:
  id: deep_sleep_1
  run_duration: 1min #10min  # Device wake up and run 60s (enough to pull data and update)
  sleep_duration: 30min  # deep sleep for 30min

interval:
  # Deep sleep
  - interval: 59s  # run this command before the end of run_duration
    then:
      - logger.log: "Entering deep sleep now momentarily..."

  # Sleep after 11:55PM until 07:30AM
  - interval: 10s
    then:
      - if:
          condition:
            lambda: |-
              auto now = id(homeassistant_time).now();
              ESP_LOGD("main", "Evaluating");
              return now.is_valid() && now.hour == 00;
          then:
            - logger.log: "After 12:00AM — entering deep sleep until 06:00."
            - deep_sleep.enter:
                id: deep_sleep_1
                until: "06:00:00"
                time_id: homeassistant_time

  # Condition: wifi connected && data retrieved && first time
  - interval: 10s  # Check every second
    then:
      - if:
          condition:
            and:
              - wifi.connected:
              - lambda: "return !id(update_done);"
          then:
            - delay: 5s
            - lambda: |-
                ESP_LOGD("Display", "Triggered Display Update...");
            - component.update: display_panel
            - lambda: "id(update_done) = true;"


sensor:
  - platform: wifi_signal
    name: "Wifi Signal"
    id: wifisignal
    unit_of_measurement: "dBm"
    entity_category: "diagnostic"
    update_interval: 60s

button:
  - platform: shutdown
    name: "Shutdown"
    entity_category: config
  - platform: restart
    name: "Restart"
    entity_category: config
  # - platform: template
  #   name: "Refresh Screen"
  #   entity_category: config
  #   on_press:
  #     - script.execute: update_screen

time:
  - platform: homeassistant
    id: homeassistant_time

text_sensor:
  - platform: homeassistant
    entity_id: weather.woodgreen
    id: myWeather
  - platform: homeassistant
    entity_id: weather.woodgreen
    id: temp
    attribute: "temperature"
  - platform: homeassistant
    entity_id: weather.woodgreen
    id: humi
    attribute: "humidity"
  - platform: homeassistant
    entity_id: weather.woodgreen
    id: press
    attribute: "pressure"
  - platform: homeassistant
    entity_id: weather.woodgreen
    id: wind
    attribute: "wind_speed"
  - platform: homeassistant
    entity_id:  sensor.current_uv_index
    id: uv
  - platform: homeassistant
    entity_id:  sensor.current_uv_level
    id: uv_level
  - platform: homeassistant
    entity_id: sensor.daily_weather_forecast_summary
    id: forecast

font:
  - file: "../config/fonts/Montserrat-Black.ttf"
    id: web_font
    size: 20
  - file: "../config/fonts/Montserrat-Black.ttf"
    id: data_font
    size: 30
  - file: "../config/fonts/Montserrat-Black.ttf"
    id: sensor_font
    size: 22
  - file: "../config/fonts/Montserrat-Black.ttf"
    id: title_font
    size: 40
  - file: "../config/fonts/Montserrat-Black.ttf"
    id: update_font
    size: 18

  - file: "gfonts://Inter@700" #
    id: font1
    size: 24

  - file: '../config/fonts/materialdesignicons-webfont.ttf' # Directory to save ttf file
    id: font_mdi_large
    size: 200
    glyphs: &mdi-weather-glyphs # https://pictogrammers.com/library/mdi/
      - "\U000F050F" # Thermometer
      - "\U000F058E" # Humidity
      - "\U000F059D" # Wind speed
      - "\U000F0D60" # Atmospheric pressure
      - "\U000F0590" # Cloudy weather
      - "\U000F0596" # Rainy weather
      - "\U000F0598" # Snowy weather
      - "\U000F0599" # Sunny weather
  - file: '../config/fonts/materialdesignicons-webfont.ttf'
    id: font_weather # Copy the above icon and change the size to 40
    size: 200
    glyphs: *mdi-weather-glyphs
  - file: '../config/fonts/materialdesignicons-webfont.ttf'
    id: img_font_sensor # Copy the above icon and change the size to 40
    size: 70
    glyphs: *mdi-weather-glyphs


# script:
#   - id: update_screen
#     then:
#       - lambda: 'id(update_done) = false;'
#       - component.update: dashboard_image

# online_image:
#   - url: "http://campus.mrv.thebends.org:10000/eink-panel/0?viewport=800x480"
#     format: png
#     id: dashboard_image
#     type: GRAYSCALE
#     update_interval: never # Never -- handled by interval script
#     on_download_finished:
#       - lambda: |-
#           if (cached) {
#             ESP_LOGD("online_image", "Cache hit: using cached image");
#           } else {
#             ESP_LOGD("online_image", "Cache miss: fresh download");
#           }
#       - component.update: display_panel


display:
  - platform: waveshare_epaper
    id: display_panel
    cs_pin: GPIO3
    dc_pin: GPIO5
    busy_pin: GPIO4
    reset_pin: GPIO2
    model: 7.50inv2
    update_interval: never # Never -- handled by interval script
    # lambda: |-
    #   // Draw the image my_online_image at position [x=0,y=0]
    #   it.image(0, 0, id(dashboard_image));
    lambda: |-
      ESP_LOGD("Display", "Updating Display @ Component...");
      if(id(wifi_status) == 0){
      //  it.print(230, 300, id(data_font), "WI-FI CONNECTING");
      }
      else{
          ESP_LOGD("Display", "Writing Weather Display...");

          // Draw weather images here
          std::string weather_string = id(myWeather).state.c_str();
          if(weather_string == "rainy" || weather_string == "lightning" || weather_string == "pouring"){
            // Draw rainy weather image
            it.printf(120, 85, id(font_weather), TextAlign::CENTER, "\U000F0596");
          }else if(weather_string == "snowy"){
            // Draw snowy weather image
            it.printf(120, 85, id(font_weather), TextAlign::CENTER, "\U000F0598");
          }else if(weather_string == "sunny" || weather_string == "windy"){
            // Draw sunny weather image
            it.printf(120, 85, id(font_weather), TextAlign::CENTER, "\U000F0599");
          }else{
            // Draw cloudy weather image
            it.printf(120, 85, id(font_weather), TextAlign::CENTER, "\U000F0590");
          }

          auto time_now = id(homeassistant_time).now();
          int day = time_now.day_of_month;
          int day_of_week = time_now.day_of_week;
          int month = time_now.month;

          // Month conversion
          const char* months[] = {
            "January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
          };
          const char* month_str = months[month - 1];  // Month index starts from 0

          // Draw the date
          ESP_LOGD("Display", "Month: %s", month_str);
          ESP_LOGD("Display", "Day: %d", day);
          it.printf(250, 85, id(title_font), "%s %d", month_str, day);

          // Get the day of the week
          const char* weekdays[] = {
              "Saturday", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday",
              "Saturday",
          };
          const char* weekday_name = weekdays[day_of_week];
          ESP_LOGD("Display", "Day of Week (n): %d", day_of_week);
          ESP_LOGD("Display", "Day of Week: %s", weekday_name);
          it.printf(250, 50, id(title_font), "%s", weekday_name);

          // define generic border info
          int w = 180, h = 120, r = 10, thickness = 4;
          
          // Draw four borders
          int x = 20;
          int y = 180;
          it.filled_rectangle(x + r, y, w - 2 * r, thickness); // Top border
          it.filled_rectangle(x + r, y + h - thickness, w - 2 * r, thickness); // Bottom border
          it.filled_rectangle(x, y + r, thickness, h - 2 * r); // Left border
          it.filled_rectangle(x + w - thickness, y + r, thickness, h - 2 * r); // Right border
          // Draw four rounded corners
          it.filled_circle(x + r, y + r, r); // Top-left corner
          it.filled_circle(x + w - r, y + r, r); // Top-right corner
          it.filled_circle(x + r, y + h - r, r); // Bottom-left corner
          it.filled_circle(x + w - r, y + h - r, r); // Bottom-right corner
          // Fill the inside with black to form a border
          it.filled_rectangle(x + thickness, y + thickness, w - 2 * thickness, h - 2 * thickness, COLOR_OFF);
          // Temperature
          it.printf(x+10, y+10, id(sensor_font), "Temperature");
          it.printf(x+45, y+75, id(img_font_sensor), TextAlign::CENTER, "\U000F050F");
          // Get temperature data
          std::string temp_str = id(temp).state.c_str();
          size_t dot_pos = temp_str.find(".");
          if (dot_pos != std::string::npos) {
            temp_str = temp_str.substr(0, dot_pos);
          }
          it.printf(x+75,y+65, id(data_font), "%s°F", temp_str.c_str());

          // Draw four borders
          x = 220;
          y = 180;
          it.filled_rectangle(x + r, y, w - 2 * r, thickness); // Top border
          it.filled_rectangle(x + r, y + h - thickness, w - 2 * r, thickness); // Bottom border
          it.filled_rectangle(x, y + r, thickness, h - 2 * r); // Left border
          it.filled_rectangle(x + w - thickness, y + r, thickness, h - 2 * r); // Right border
          // Draw four rounded corners
          it.filled_circle(x + r, y + r, r); // Top-left corner
          it.filled_circle(x + w - r, y + r, r); // Top-right corner
          it.filled_circle(x + r, y + h - r, r); // Bottom-left corner
          it.filled_circle(x + w - r, y + h - r, r); // Bottom-right corner
          // Fill the inside with black to form a border
          it.filled_rectangle(x + thickness, y + thickness, w - 2 * thickness, h - 2 * thickness, COLOR_OFF);
          // Humidity
          it.printf(x+10, y+10, id(sensor_font), "Humidity");
          it.printf(x+45, y+75, id(img_font_sensor), TextAlign::CENTER, "\U000F058E");
          // Get humidity data
          std::string humi_str = id(humi).state.c_str();
          size_t dot_poss = humi_str.find(".");
          if (dot_poss != std::string::npos) {
            humi_str = humi_str.substr(0, dot_pos);
          }
          it.printf(x+75,y+65, id(data_font), "%s%%", humi_str.c_str());

          // Draw four borders
          x = 20;
          y = 320;
          it.filled_rectangle(x + r, y, w - 2 * r, thickness); // Top border
          it.filled_rectangle(x + r, y + h - thickness, w - 2 * r, thickness); // Bottom border
          it.filled_rectangle(x, y + r, thickness, h - 2 * r); // Left border
          it.filled_rectangle(x + w - thickness, y + r, thickness, h - 2 * r); // Right border
          // Draw four rounded corners
          it.filled_circle(x + r, y + r, r); // Top-left corner
          it.filled_circle(x + w - r, y + r, r); // Top-right corner
          it.filled_circle(x + r, y + h - r, r); // Bottom-left corner
          it.filled_circle(x + w - r, y + h - r, r); // Bottom-right corner
          // Fill the inside with black to form a border
          it.filled_rectangle(x + thickness, y + thickness, w - 2 * thickness, h - 2 * thickness, COLOR_OFF);
          // UV Index
          it.printf(x+10, y+10, id(sensor_font), "UV Index");
          it.printf(x+45, y+75, id(img_font_sensor), TextAlign::CENTER, "\U000F0599");
          // Get UV index data. Print the numeric value and text value.
          it.printf(x+85,y+50, id(data_font), "%s", id(uv).state.c_str());
          it.printf(x+85,y+78, id(sensor_font), "%s", id(uv_level).state.c_str());

          // Draw four borders
          x = 220;
          y = 320;
          it.filled_rectangle(x + r, y, w - 2 * r, thickness); // Top border
          it.filled_rectangle(x + r, y + h - thickness, w - 2 * r, thickness); // Bottom border
          it.filled_rectangle(x, y + r, thickness, h - 2 * r); // Left border
          it.filled_rectangle(x + w - thickness, y + r, thickness, h - 2 * r); // Right border
          // Draw four rounded corners
          it.filled_circle(x + r, y + r, r); // Top-left corner
          it.filled_circle(x + w - r, y + r, r); // Top-right corner
          it.filled_circle(x + r, y + h - r, r); // Bottom-left corner
          it.filled_circle(x + w - r, y + h - r, r); // Bottom-right corner
          // Fill the inside with black to form a border
          it.filled_rectangle(x + thickness, y + thickness, w - 2 * thickness, h - 2 * thickness, COLOR_OFF);
          // Wind Speed
          it.printf(x+10, y+10, id(sensor_font), "Wind Speed");
          it.printf(x+45, y+75, id(img_font_sensor), TextAlign::CENTER, "\U000F059D");
          // Get wind speed data
          it.printf(x+85,y+50, id(data_font), "%s", id(wind).state.c_str());
          it.printf(x+85,y+78, id(sensor_font), "mph");

          //
          // FORECAST
          //

          std::string input = id(forecast).state.c_str();
          std::string output;
          size_t max_len = 25;
          size_t line_len = 0;
          size_t i = 0;

          // Word wrap without breaking words
          while(i < input.length()) {
            size_t next_space = input.find(' ', i);
            if(next_space == std::string::npos) next_space = input.length();
            size_t word_len = next_space - i;

            if(line_len + word_len > max_len) {
              output += '\n';
              line_len = 0;
            }

            output += input.substr(i, word_len);
            line_len += word_len;

            if(next_space < input.length()) {
              output += ' ';
              line_len += 1;
            }

            i = next_space + 1;
          }

          // Now split output by '\n' and print line by line
          size_t y_start = 170;  // bottom-left vertical start (adjust as needed)
          size_t x_start = 430;   // left margin
          int line_height = 22;  // pixels between lines, adjust to your font size
          size_t pos = 0;
          size_t next_pos;
          int line_num = 0;
          while((next_pos = output.find('\n', pos)) != std::string::npos) {
            std::string line = output.substr(pos, next_pos - pos);
            it.print(x_start, y_start + line_num * line_height, id(sensor_font), line.c_str());
            pos = next_pos + 1;
            line_num++;
          }
          // Print last line after last '\n'
          if(pos < output.length()) {
            std::string line = output.substr(pos);
            it.print(x_start, y_start + line_num * line_height, id(sensor_font), line.c_str());
          }

          // Draw update time
          it.strftime(10, 452, id(update_font), "Updated %b %d, %Y %I:%M %p", time_now);
      }
